diff --git a/.gitignore b/.gitignore
index 7e842be..8c06eba 100644
--- a/.gitignore
+++ b/.gitignore
@@ -107,3 +107,9 @@ venv.bak/
 # mypy
 .mypy_cache/
 
+output/*
+models/*
+data/*
+vposer_v1_0/*
+data.zip
+vposer_V1_0.zip
\ No newline at end of file
diff --git a/cfg_files/fit_smplx.yaml b/cfg_files/fit_smplx.yaml
index 310cd87..8d01d92 100644
--- a/cfg_files/fit_smplx.yaml
+++ b/cfg_files/fit_smplx.yaml
@@ -11,7 +11,7 @@ result_folder: 'results'
 gender: "neutral"
 model_type: 'smplx'
 # Flag for using the GPU
-use_cuda: True
+use_cuda: Falses
 float_dtype: "float32"
 use_joints_conf: True
 use_pca: True
@@ -28,7 +28,7 @@ focal_length: 5000
 num_pca_comps: 12
 # The constant for the robust loss function
 rho: 100
-interpenetration: True
+interpenetration: Falses
 df_cone_height: 0.0001
 # Upper arms and Spine 2
 # Neck and jaw
diff --git a/smplifyx/fit_single_frame.py b/smplifyx/fit_single_frame.py
index 30c9982..dd48789 100644
--- a/smplifyx/fit_single_frame.py
+++ b/smplifyx/fit_single_frame.py
@@ -391,13 +391,17 @@ def fit_single_frame(img,
         for or_idx, orient in enumerate(tqdm(orientations, desc='Orientation')):
             opt_start = time.time()
 
+             # Damar betas
             new_params = defaultdict(global_orient=orient,
-                                     body_pose=body_mean_pose)
+                                     body_pose=body_mean_pose,
+                                     betas = torch.tensor([[-0.5428955554962158, 0.10958688706159592, 0.18718387186527252, -0.16433975100517273, -0.01722436398267746, 0.039273880422115326, -0.10529498010873795, 0.024629995226860046, 0.165267676115036, 0.11545940488576889]], dtype=torch.float32))
+
             body_model.reset_params(**new_params)
             if use_vposer:
                 with torch.no_grad():
                     pose_embedding.fill_(0)
 
+            body_model.betas.requires_grad = False
             for opt_idx, curr_weights in enumerate(tqdm(opt_weights, desc='Stage')):
 
                 body_params = list(body_model.parameters())
@@ -469,8 +473,13 @@ def fit_single_frame(img,
             result.update({key: val.detach().cpu().numpy()
                            for key, val in body_model.named_parameters()})
             if use_vposer:
-                result['body_pose'] = pose_embedding.detach().cpu().numpy()
-
+                # Below vpose.decode is for MPG's (and meshcapade github master) add-on to correctly load 'pkl' file, target shape is (NUM_JOINTS,3)
+                result['body_pose'] = vposer.decode(pose_embedding, output_type='aa').detach().cpu().numpy().reshape((1,63))
+                # Original code
+                # result['body_pose'] = pose_embedding.detach().cpu().numpy()
+            # Set 'global_orient' to zero while keeping its shape for saving pkl
+            # TODO: we need to save global_orient in other form for later use in simulation
+            result['global_orient'] = np.zeros_like(result['global_orient'])
             results.append({'loss': final_loss_val,
                             'result': result})
 
@@ -483,9 +492,17 @@ def fit_single_frame(img,
             pickle.dump(results[min_idx]['result'], result_file, protocol=2)
 
     if save_meshes or visualize:
+        # vpose.decode for the pkl above does not share here, so have to call it again
         body_pose = vposer.decode(
             pose_embedding,
             output_type='aa').view(1, -1) if use_vposer else None
+        # If need to get the joints with T posed, otherwise have to load standing pose first
+        # Which means no prediction is expected, rather just get the joints coordinates from default pose
+        # No need to reset pose in pkl above, since meaningless
+        # If need to use results from prediction, comment below
+        #body_pose = torch.zeros_like(body_pose, device=body_pose.device, requires_grad=True)
+        #body_model.reset_params(body_pose=body_pose)
+
 
         model_type = kwargs.get('model_type', 'smpl')
         append_wrists = model_type == 'smpl' and use_vposer
@@ -495,15 +512,38 @@ def fit_single_frame(img,
                                          device=body_pose.device)
                 body_pose = torch.cat([body_pose, wrist_pose], dim=1)
 
+        # above we set the result's global_orient for saving pkl, but here we need to set to body_model for regression joints
+        # set the body pose tensor to None so no local rotations are applied, for saving joint coordinates
+        global_orient= torch.zeros(1, 3, device='cuda:0', requires_grad=True)
+        body_model.reset_params(global_orient=global_orient)
+        # here if want to save the joints in T pose, set body_pose to None
+        # or for standing pose, set body_pose to standing_pose
         model_output = body_model(return_verts=True, body_pose=body_pose)
+        # Get the joints coordinates from the model
+        joints = model_output.joints.detach().cpu().numpy().squeeze()
+        joints *= 1000 # convert to mm
+        # rotate joints around x-axis for +90 degree
+        import trimesh
+        rot = trimesh.transformations.rotation_matrix(
+            np.radians(90), [1, 0, 0])
+        joints = trimesh.transform_points(joints, rot)
+        # Just for checking if the global_orient is reset
+        print("body_model's orient: ", body_model.global_orient)
+        #save joints as json
+        import json
+        with open('joints.json', 'w') as f:
+            json.dump(joints.tolist(), f)
+
         vertices = model_output.vertices.detach().cpu().numpy().squeeze()
 
-        import trimesh
+        #import trimesh
 
         out_mesh = trimesh.Trimesh(vertices, body_model.faces, process=False)
         rot = trimesh.transformations.rotation_matrix(
-            np.radians(180), [1, 0, 0])
-        out_mesh.apply_transform(rot)
+            np.radians(180), [1, 0, 0]) # Why rotate 180 degrees around x-axis?
+        scale_transform = trimesh.transformations.scale_matrix(1000, [0, 0, 0]) # origin is [0, 0, 0]
+        out_mesh.apply_transform(scale_transform)
+        #out_mesh.apply_transform(rot) # Why rotate 180 degrees around x-axis?
         out_mesh.export(mesh_fn)
 
     if visualize:
diff --git a/smplifyx/main.py b/smplifyx/main.py
index 7fd6fe8..5df4a82 100644
--- a/smplifyx/main.py
+++ b/smplifyx/main.py
@@ -77,8 +77,8 @@ def main(**args):
 
     use_cuda = args.get('use_cuda', True)
     if use_cuda and not torch.cuda.is_available():
-        print('CUDA is not available, exiting!')
-        sys.exit(-1)
+        print('CUDA is not available, still use cpu version!')
+        #sys.exit(-1)
 
     img_folder = args.pop('img_folder', 'images')
     dataset_obj = create_dataset(img_folder=img_folder, **args)
